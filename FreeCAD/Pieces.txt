import FreeCAD, Draft, Arch

SiteGIS = Arch.makeSite([],[],"GIS-Site")

SiteGIS.Longitude = -46.38
SiteGIS.Latitude = -23.33
SiteGIS.CRS EPSG SRID = 
SiteGIS.CRS EPSG Description = 
SiteGIS.CRS_x = 
SiteGIS.CRS_y = 
SiteGIS.Address = ""
SiteGIS.Country = ""
SiteGIS.City Code = ""
SiteGIS.Postal Code = ""

SiteGIS.Url = ""

GIS2BIM_NominatimAPIwebRequestPart1 = "https://nominatim.openstreetmap.org/search/"
GIS2BIM_NominatimAPIwebRequestLastPart = "?format=xml&addressdetails=1&limit=1&polygon_svg=1"

import requests

def GIS2BIM_NominatimAPI(streetname, housenumber, city, country):
    webRequestPart1 = GIS2BIM_NominatimAPIwebRequestPart1
    webRequestPart2 = "%20"
    webRequestLastPart = GIS2BIM_NominatimAPIwebRequestLastPart
    myrequestURL = webRequestPart1 + city + webRequestPart2 + streetname + webRequestPart2 + housenumber + webRequestPart2 + country + webRequestLastPart
#    urlFile = urllib.request.urlopen(myrequestURL)
#    tree = ET.parse(urlFile)
    return myrequestURL




a = GIS2BIM_NominatimAPI("warmoeskade", "2", "", "")
response = requests.get(a)

#urlFile = urllib.request.urlopen(a)
#b = urlFile.read()
print(response)

## Not working. HTTPS is very complicated

def GIS2BIM_TransformCRS_epsg(SourceCRS,TargetCRS,X,Y)
	#transform coordinates between different Coordinate Reference Systems using EPSG-server
	SourceCRS = str(SourceCRS)
	TargetCRS = str(TargetCRS)
	X = str(X)
	Y = str(Y)
	requestURL = "http://epsg.io/trans?" + "&s_srs=" + SourceCRS + "&t_srs=" + TargetCRS + "&x=" + X + "&y=" + Y + "&format=json&trans=1&callback=jsonpFunction"
	return requestURL
	
GIS2BIM_TransformCRS_epsg(4326,28992,104000,450000)












var map = L.map('map').setView([51.505, -0.09], 13);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

L.marker([51.5, -0.09]).addTo(map)
    .bindPopup('A pretty CSS3 popup.<br> Easily customizable.')
    .openPopup();
	
	
https://srinikom.github.io/pyside-docs/PySide/QtWebKit/index.html



layer1 = Draft.make_layer()
layer1.Label = "GIS 2D Cadastral Parcels"
layer1 = Draft.make_layer()
layer1.Label = "GIS 2D Building Outlines"
layer1 = Draft.make_layer()
layer1.Label = "GIS 2D Building Countour Destination Plan"
layer1 = Draft.make_layer()
layer1.Label = "GIS Annotations"
layer1 = Draft.make_layer()
layer1.Label = "GIS 3D Builings"
layer1 = Draft.make_layer()
layer1.Label = "GIS Aerialphoto"

FreeCAD.ActiveDocument.recompute()



import FreeCAD

doc = FreeCAD.ActiveDocument

pcube = doc.addObject("Part::Box")

pcube.Length = 10000
pcube.Width = 10000
pcube.Height = 50000

obj = doc.addObject("App::DocumentObjectGroup", "Group2")

obj.addObjects([pcube])

FreeCAD.ActiveDocument.recompute()


import FreeCAD,FreeCADGui,Part
 
# CHANGE THE LINE BELOW
path_to_ui = "C:\Users\yorik\Documents\dialog.ui"
 
class BoxTaskPanel:
   def __init__(self):
       # this will create a Qt widget from our ui file
       self.form = FreeCADGui.PySideUic.loadUi(path_to_ui)
 
   def accept(self):
       length = self.form.BoxLength.value()
       width = self.form.BoxWidth.value()
       height = self.form.BoxHeight.value()
       if (length == 0) or (width == 0) or (height == 0):
           print("Error! None of the values can be 0!")
           # we bail out without doing anything
           return
       box = Part.makeBox(length,width,height)
       Part.show(box)
       FreeCADGui.Control.closeDialog()
        
panel = BoxTaskPanel()
FreeCADGui.Control.showDialog(panel)


import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math

#The inputs to this node will be stored as a list in the IN variables.
dataEnteringNode = IN
lat = IN[0]
long = IN[1]
width = IN[2]

class GeoLocation:
    '''

#    Class representing a coordinate on a sphere, most likely Earth.
#    This class is based from the code smaple in this paper:
#        http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates
#    The owner of that website, Jan Philip Matuschek, is the full owner of
#    his intellectual property. This class is simply a Python port of his very
#    useful Java code. All code written by Jan Philip Matuschek and ported by me
#    (which is all of this class) is owned by Jan Philip Matuschek.
#    '''

    MIN_LAT = math.radians(-90)
    MAX_LAT = math.radians(90)
    MIN_LON = math.radians(-180)
    MAX_LON = math.radians(180)
    EARTH_RADIUS = 6378.1  # kilometers

    @classmethod
    def from_degrees(cls, deg_lat, deg_lon):
        rad_lat = math.radians(deg_lat)
        rad_lon = math.radians(deg_lon)
        return GeoLocation(rad_lat, rad_lon, deg_lat, deg_lon)

    @classmethod
    def from_radians(cls, rad_lat, rad_lon):
        deg_lat = math.degrees(rad_lat)
        deg_lon = math.degrees(rad_lon)
        return GeoLocation(rad_lat, rad_lon, deg_lat, deg_lon)

    def __init__(
            self,
            rad_lat,
            rad_lon,
            deg_lat,
            deg_lon
    ):
        self.rad_lat = float(rad_lat)
        self.rad_lon = float(rad_lon)
        self.deg_lat = float(deg_lat)
        self.deg_lon = float(deg_lon)
        self._check_bounds()

    def __str__(self):
        degree_sign = u'\N{DEGREE SIGN}'
        return ("{0:.20f}, {1:.20f}").format(
            self.deg_lat, self.deg_lon, self.rad_lat, self.rad_lon)

    def _check_bounds(self):

        if (self.rad_lat < GeoLocation.MIN_LAT
            or self.rad_lat > GeoLocation.MAX_LAT
            or self.rad_lon < GeoLocation.MIN_LON
            or self.rad_lon > GeoLocation.MAX_LON):
            raise Exception("Illegal arguments")

    def distance_to(self, other, radius=EARTH_RADIUS):

        '''

        Computes the great circle distance between this GeoLocation instance
        and the other.
        '''

        return radius * math.acos(
            math.sin(self.rad_lat) * math.sin(other.rad_lat) +
            math.cos(self.rad_lat) *
            math.cos(other.rad_lat) *
            math.cos(self.rad_lon - other.rad_lon)
        )

    def bounding_locations(self, distance, radius=EARTH_RADIUS):

        '''
        Computes the bounding coordinates of all points on the surface
        of a sphere that has a great circle distance to the point represented
        by this GeoLocation instance that is less or equal to the distance argument.

        Param:
            distance - the distance from the point represented by this GeoLocation
                       instance. Must be measured in the same unit as the radius
                       argument (which is kilometers by default)
            radius   - the radius of the sphere. defaults to Earth's radius.
        Returns a list of two GeoLoations - the SW corner and the NE corner - that
        represents the bounding box.
        '''

        if radius < 0 or distance < 0:
            raise Exception("Illegal arguments")

        # angular distance in radians on a great circle

        rad_dist = distance / radius
        min_lat = self.rad_lat - rad_dist
        max_lat = self.rad_lat + rad_dist

        if min_lat > GeoLocation.MIN_LAT and max_lat < GeoLocation.MAX_LAT:
            delta_lon = math.asin(math.sin(rad_dist) / math.cos(self.rad_lat))
            min_lon = self.rad_lon - delta_lon
            if min_lon < GeoLocation.MIN_LON:
                min_lon += 2 * math.pi
            max_lon = self.rad_lon + delta_lon

            if max_lon > GeoLocation.MAX_LON:
                max_lon -= 2 * math.pi

        # a pole is within the distance
        else:

            min_lat = max(min_lat, GeoLocation.MIN_LAT)
            max_lat = min(max_lat, GeoLocation.MAX_LAT)
            min_lon = GeoLocation.MIN_LON
            max_lon = GeoLocation.MAX_LON

        return [GeoLocation.from_radians(min_lat, min_lon),
                GeoLocation.from_radians(max_lat, max_lon)]

loc = GeoLocation.from_degrees(lat,long)
distance = width
SW_loc, NE_loc = loc.bounding_locations(distance)

#Assign your output to the OUT variable.
OUT = SW_loc, NE_loc